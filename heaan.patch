diff --git a/HEAAN/src/Ciphertext.cpp b/HEAAN/src/Ciphertext.cpp
index 14a1a32..ffde34b 100644
--- a/HEAAN/src/Ciphertext.cpp
+++ b/HEAAN/src/Ciphertext.cpp
@@ -24,13 +24,13 @@ Ciphertext::Ciphertext(const Ciphertext& o) : logp(o.logp), logq(o.logq), n(o.n)
 	}
 }
 
-void Ciphertext::copyParams(Ciphertext& o) {
+void Ciphertext::copyParams(const Ciphertext& o) {
 	logp = o.logp;
 	logq = o.logq;
 	n = o.n;
 }
 
-void Ciphertext::copy(Ciphertext& o) {
+void Ciphertext::copy(const Ciphertext& o) {
 	copyParams(o);
 	for (long i = 0; i < N; ++i) {
 		ax[i] = o.ax[i];
diff --git a/HEAAN/src/Ciphertext.h b/HEAAN/src/Ciphertext.h
index bd7fc78..8bc2292 100644
--- a/HEAAN/src/Ciphertext.h
+++ b/HEAAN/src/Ciphertext.h
@@ -30,9 +30,9 @@ public:
 
 	Ciphertext(const Ciphertext& o);
 
-	void copyParams(Ciphertext& o);
+	void copyParams(const Ciphertext& o);
 
-	void copy(Ciphertext& o);
+	void copy(const Ciphertext& o);
 
 	void free();
 
diff --git a/HEAAN/src/EvaluatorUtils.cpp b/HEAAN/src/EvaluatorUtils.cpp
index 4422404..0a7bab7 100644
--- a/HEAAN/src/EvaluatorUtils.cpp
+++ b/HEAAN/src/EvaluatorUtils.cpp
@@ -91,13 +91,13 @@ ZZ EvaluatorUtils::scaleUpToZZ(const RR& x, const long logp) {
 //----------------------------------------------------------------------------------
 
 
-void EvaluatorUtils::leftRotateAndEqual(complex<double>* vals, const long n, const long r) {
+void EvaluatorUtils::leftRotateAndEqual(complex<RR>* vals, const long n, const long r) {
 	long rem = r % n;
 	if(rem != 0) {
 		long divisor = GCD(rem, n);
 		long steps = n / divisor;
 		for (long i = 0; i < divisor; ++i) {
-			complex<double> tmp = vals[i];
+			complex<RR> tmp = vals[i];
 			long idx = i;
 			for (long j = 0; j < steps - 1; ++j) {
 				vals[idx] = vals[(idx + rem) % n];
@@ -108,7 +108,24 @@ void EvaluatorUtils::leftRotateAndEqual(complex<double>* vals, const long n, con
 	}
 }
 
-void EvaluatorUtils::rightRotateAndEqual(complex<double>* vals, const long n, const long r) {
+void EvaluatorUtils::leftRotateAndEqual(complex<double>* vals, const long n, const long r) {
+    long rem = r % n;
+    if(rem != 0) {
+        long divisor = GCD(rem, n);
+        long steps = n / divisor;
+        for (long i = 0; i < divisor; ++i) {
+            complex<double> tmp = vals[i];
+            long idx = i;
+            for (long j = 0; j < steps - 1; ++j) {
+                vals[idx] = vals[(idx + rem) % n];
+                idx = (idx + rem) % n;
+            }
+            vals[idx] = tmp;
+        }
+    }
+}
+
+void EvaluatorUtils::rightRotateAndEqual(complex<RR>* vals, const long n, const long r) {
 	long rem = r % n;
 	rem = (n - rem) % n;
 	leftRotateAndEqual(vals, n, rem);
diff --git a/HEAAN/src/EvaluatorUtils.h b/HEAAN/src/EvaluatorUtils.h
index 9e2d518..c841f47 100644
--- a/HEAAN/src/EvaluatorUtils.h
+++ b/HEAAN/src/EvaluatorUtils.h
@@ -40,7 +40,9 @@ public:
 	//   DOUBLE & RR <-> ZZ
 	//----------------------------------------------------------------------------------
 
-	static double scaleDownToReal(const NTL::ZZ& x, const long logp);
+//	static double scaleDownToReal(const NTL::ZZ& x, const long logp);
+
+    static double scaleDownToReal(const NTL::ZZ& x, const long logp);
 
 	static NTL::ZZ scaleUpToZZ(const double x, const long logp);
 
@@ -51,10 +53,10 @@ public:
 	//   ROTATIONS
 	//----------------------------------------------------------------------------------
 
+    static void leftRotateAndEqual(std::complex<double>* vals, const long n, const long r);
+	static void leftRotateAndEqual(std::complex<NTL::RR>* vals, const long n, const long r);
 
-	static void leftRotateAndEqual(std::complex<double>* vals, const long n, const long r);
-
-	static void rightRotateAndEqual(std::complex<double>* vals, const long n, const long r);
+	static void rightRotateAndEqual(std::complex<NTL::RR>* vals, const long n, const long r);
 
 };
 
diff --git a/HEAAN/src/Params.h b/HEAAN/src/Params.h
index 3924cff..af75c0c 100644
--- a/HEAAN/src/Params.h
+++ b/HEAAN/src/Params.h
@@ -10,10 +10,13 @@
 
 #include <NTL/ZZ.h>
 
+// alternative is NTL::RR
+#define BOOT_PREC_TYPE double
+
 namespace heaan {
 
 static const long logN = 16;
-static const long logQ = 800; // 128-bit security
+static const long logQ = 1250; // 128-bit security
 
 static const double sigma = 3.2;
 static const long h = 64;
diff --git a/HEAAN/src/Ring.cpp b/HEAAN/src/Ring.cpp
index 515ba7e..6b2436d 100644
--- a/HEAAN/src/Ring.cpp
+++ b/HEAAN/src/Ring.cpp
@@ -23,6 +23,10 @@ using namespace NTL;
 
 namespace heaan {
 
+std::complex<double> Ring::cmplxRR2double(const std::complex<NTL::RR> &val) {
+    return std::complex<double>(to_double(val.real()), to_double(val.imag()));
+}
+
 Ring::Ring() {
 
 	qpows = new ZZ[logQQ + 1];
@@ -39,9 +43,9 @@ Ring::Ring() {
 		fivePows %= M;
 	}
 
-	ksiPows = new complex<double>[M + 1];
+	ksiPows = new complex<BOOT_PREC_TYPE>[M + 1];
 	for (long j = 0; j < M; ++j) {
-		double angle = 2.0 * M_PI * j / M;
+		BOOT_PREC_TYPE angle = 2.0 * conv<BOOT_PREC_TYPE>(Pi) * j / M;
 		ksiPows[j].real(cos(angle));
 		ksiPows[j].imag(sin(angle));
 	}
@@ -62,6 +66,19 @@ void Ring::arrayBitReverse(complex<double>* vals, long n) {
 	}
 }
 
+void Ring::arrayBitReverse(complex<RR>* vals, long n) {
+    for (long i = 1, j = 0; i < n; ++i) {
+        long bit = n >> 1;
+        for (; j >= bit; bit >>= 1) {
+            j -= bit;
+        }
+        j += bit;
+        if (i < j) {
+            swap(vals[i], vals[j]);
+        }
+    }
+}
+
 void Ring::EMB(complex<double>* vals, long n) {
 	arrayBitReverse(vals, n);
 	for (long len = 2; len <= n; len <<= 1) {
@@ -73,7 +90,7 @@ void Ring::EMB(complex<double>* vals, long n) {
 				long idx = ((rotGroup[j] % lenq)) * gap;
 				complex<double> u = vals[i + j];
 				complex<double> v = vals[i + j + lenh];
-				v *= ksiPows[idx];
+				v *= cmplxRR2double(ksiPows[idx]);
 				vals[i + j] = u + v;
 				vals[i + j + lenh] = u - v;
 			}
@@ -91,7 +108,7 @@ void Ring::EMBInvLazy(complex<double>* vals, long n) {
 				long idx = (lenq - (rotGroup[j] % lenq)) * gap;
 				complex<double> u = vals[i + j] + vals[i + j + lenh];
 				complex<double> v = vals[i + j] - vals[i + j + lenh];
-				v *= ksiPows[idx];
+				v *= cmplxRR2double(ksiPows[idx]);
 				vals[i + j] = u;
 				vals[i + j + lenh] = v;
 			}
@@ -100,6 +117,25 @@ void Ring::EMBInvLazy(complex<double>* vals, long n) {
 	arrayBitReverse(vals, n);
 }
 
+void Ring::EMBInvLazy(complex<RR>* vals, long n) {
+    for (long len = n; len >= 1; len >>= 1) {
+        for (long i = 0; i < n; i += len) {
+            long lenh = len >> 1;
+            long lenq = len << 2;
+            long gap = M / lenq;
+            for (long j = 0; j < lenh; ++j) {
+                long idx = (lenq - (rotGroup[j] % lenq)) * gap;
+                complex<RR> u = vals[i + j] + vals[i + j + lenh];
+                complex<RR> v = vals[i + j] - vals[i + j + lenh];
+                v *= ksiPows[idx];
+                vals[i + j] = u;
+                vals[i + j + lenh] = v;
+            }
+        }
+    }
+    arrayBitReverse(vals, n);
+}
+
 void Ring::EMBInv(complex<double>* vals, long n) {
 	EMBInvLazy(vals, n);
 	for (long i = 0; i < n; ++i) {
@@ -107,8 +143,15 @@ void Ring::EMBInv(complex<double>* vals, long n) {
 	}
 }
 
+void Ring::EMBInv(complex<RR>* vals, long n) {
+    EMBInvLazy(vals, n);
+    for (long i = 0; i < n; ++i) {
+        vals[i] /= RR(n);
+    }
+}
+
 void Ring::encode(ZZ* mx, double* vals, long slots, long logp) {
-	complex<double>* uvals = new complex<double>[slots];
+	auto* uvals = new complex<double>[slots];
 	long i, jdx, idx;
 	for (i = 0; i < slots; ++i) {
 		uvals[i].real(vals[i]);
@@ -126,7 +169,7 @@ void Ring::encode(ZZ* mx, double* vals, long slots, long logp) {
 }
 
 void Ring::encode(ZZ* mx, complex<double>* vals, long slots, long logp) {
-	complex<double>* uvals = new complex<double> [slots];
+	auto* uvals = new complex<RR> [slots];
 	long i, jdx, idx;
 	copy(vals, vals + slots, uvals);
 	long gap = Nh / slots;
@@ -155,6 +198,12 @@ void Ring::decode(ZZ* mx, complex<double>* vals, long slots, long logp, long log
 }
 
 void Ring::addBootContext(long logSlots, long logp) {
+    /*
+     * functions called:
+     *  EvaluatorUtils::rightRotateAndEqual
+     *  EMBInv -> EMBInvLazy -> arrayBitReverse
+     *  EvaluatorUtils::scaleUpToZZ
+     * */
 	if (bootContextMap.find(logSlots) == bootContextMap.end()) {
 		long slots = 1 << logSlots;
 		long dslots = slots << 1;
@@ -177,9 +226,9 @@ void Ring::addBootContext(long logSlots, long logp) {
 		long bnd2;
 
 		ZZ* pvec = new ZZ[N];
-		complex<double>* pvals = new complex<double> [dslots];
+		auto* pvals = new complex<RR> [dslots];
 
-		double c = 0.25 / M_PI;
+		RR c = 0.25 / Pi;
 
 		if (logSlots < logNh) {
 			long dgap = gap >> 1;
@@ -214,9 +263,9 @@ void Ring::addBootContext(long logSlots, long logp) {
 			}
 
 			for (i = 0; i < slots; ++i) {
-				pvals[i] = 0.0;
-				pvals[i + slots].real(0);
-				pvals[i + slots].imag(-c);
+				pvals[i] = RR(0.0);
+				pvals[i + slots].real(RR(0));
+				pvals[i + slots].imag(RR(-c));
 			}
 			EMBInv(pvals, dslots);
 			for (i = 0, jdx = Nh, idx = 0; i < dslots; ++i, jdx += dgap, idx += dgap) {
@@ -232,8 +281,8 @@ void Ring::addBootContext(long logSlots, long logp) {
 			}
 
 			for (i = 0; i < slots; ++i) {
-				pvals[i] = c;
-				pvals[i + slots] = 0;
+				pvals[i] = RR(c);
+				pvals[i + slots] = RR(0);
 			}
 
 			EMBInv(pvals, dslots);
diff --git a/HEAAN/src/Ring.h b/HEAAN/src/Ring.h
index b2aa285..d74eaff 100644
--- a/HEAAN/src/Ring.h
+++ b/HEAAN/src/Ring.h
@@ -25,12 +25,13 @@ public:
 
 	NTL::ZZ* qpows;
 	long* rotGroup;
-	std::complex<double>* ksiPows;
+	std::complex<BOOT_PREC_TYPE>* ksiPows;
 	std::map<long, BootContext*> bootContextMap;
 	RingMultiplier multiplier;
 
 	Ring();
 
+    static std::complex<double> cmplxRR2double(const std::complex<NTL::RR>& val);
 
 	//----------------------------------------------------------------------------------
 	//   Encode & Decode
@@ -38,12 +39,16 @@ public:
 
 
 	void arrayBitReverse(std::complex<double>* vals, long size);
+    void arrayBitReverse(std::complex<NTL::RR>* vals, long size);
 
 	void EMB(std::complex<double>* vals, long size);
 
 	void EMBInvLazy(std::complex<double>* vals, long size);
+    void EMBInvLazy(std::complex<NTL::RR>* vals, long size);
+
 
 	void EMBInv(std::complex<double>* vals, long size);
+    void EMBInv(std::complex<NTL::RR>* val, long size);
 
 	void encode(NTL::ZZ* mx, double* vals, long slots, long logp);
 
diff --git a/HEAAN/src/Scheme.cpp b/HEAAN/src/Scheme.cpp
index 0b1fa9a..cb6d2bc 100644
--- a/HEAAN/src/Scheme.cpp
+++ b/HEAAN/src/Scheme.cpp
@@ -208,7 +208,7 @@ void Scheme::encode(Plaintext& plain, complex<double>* vals, long n, long logp,
 }
 
 complex<double>* Scheme::decode(Plaintext& plain) {
-	complex<double>* res = new complex<double>[plain.n];
+	auto* res = new complex<double>[plain.n];
 	ring.decode(plain.mx, res, plain.n, plain.logp, plain.logq);
 	return res;
 }
@@ -380,7 +380,7 @@ complex<double> Scheme::decryptSingle(SecretKey& secretKey, Ciphertext& cipher)
 
 //-----------------------------------------
 
-void Scheme::negate(Ciphertext& res, Ciphertext& cipher) {
+void Scheme::negate(Ciphertext& res, const Ciphertext &cipher) {
 	res.copyParams(cipher);
 	ring.negate(res.ax, cipher.ax);
 	ring.negate(res.bx, cipher.bx);
@@ -391,14 +391,14 @@ void Scheme::negateAndEqual(Ciphertext& cipher) {
 	ring.negateAndEqual(cipher.bx);
 }
 
-void Scheme::add(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::add(Ciphertext& res, const Ciphertext &cipher1, const Ciphertext &cipher2) {
 	ZZ q = ring.qpows[cipher1.logq];
 	res.copyParams(cipher1);
 	ring.add(res.ax, cipher1.ax, cipher2.ax, q);
 	ring.add(res.bx, cipher1.bx, cipher2.bx, q);
 }
 
-void Scheme::addAndEqual(Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::addAndEqual(Ciphertext& cipher1, const Ciphertext &cipher2) {
 	ZZ q = ring.qpows[cipher1.logq];
 	ring.addAndEqual(cipher1.ax, cipher2.ax, q);
 	ring.addAndEqual(cipher1.bx, cipher2.bx, q);
@@ -406,21 +406,21 @@ void Scheme::addAndEqual(Ciphertext& cipher1, Ciphertext& cipher2) {
 
 //-----------------------------------------
 
-void Scheme::addConst(Ciphertext& res, Ciphertext& cipher, double cnst, long logp) {
+void Scheme::addConst(Ciphertext& res, const Ciphertext &cipher, double cnst, long logp) {
 	ZZ q = ring.qpows[cipher.logq];
 	ZZ cnstZZ = logp < 0 ? EvaluatorUtils::scaleUpToZZ(cnst, cipher.logp) : EvaluatorUtils::scaleUpToZZ(cnst, logp);
 	res.copy(cipher);
 	AddMod(res.bx[0], res.bx[0], cnstZZ, q);
 }
 
-void Scheme::addConst(Ciphertext& res, Ciphertext& cipher, RR& cnst, long logp) {
+void Scheme::addConst(Ciphertext& res, const Ciphertext &cipher, const RR &cnst, long logp) {
 	ZZ q = ring.qpows[cipher.logq];
 	ZZ cnstZZ = logp < 0 ? EvaluatorUtils::scaleUpToZZ(cnst, cipher.logp) : EvaluatorUtils::scaleUpToZZ(cnst, logp);
 	res.copy(cipher);
 	AddMod(res.bx[0], res.bx[0], cnstZZ, q);
 }
 
-void Scheme::addConst(Ciphertext& res, Ciphertext& cipher, complex<double> cnst, long logp) {
+void Scheme::addConst(Ciphertext& res, const Ciphertext &cipher, complex<double> cnst, long logp) {
 	ZZ q = ring.qpows[cipher.logq];
 	ZZ cnstZZ = logp < 0 ? EvaluatorUtils::scaleUpToZZ(cnst.real(), cipher.logp) : EvaluatorUtils::scaleUpToZZ(cnst.real(), logp);
 	res.copy(cipher);
@@ -433,7 +433,7 @@ void Scheme::addConstAndEqual(Ciphertext& cipher, double cnst, long logp) {
 	AddMod(cipher.bx[0], cipher.bx[0], cnstZZ, q);
 }
 
-void Scheme::addConstAndEqual(Ciphertext& cipher, RR& cnst, long logp) {
+void Scheme::addConstAndEqual(Ciphertext& cipher, const RR &cnst, long logp) {
 	ZZ q = ring.qpows[cipher.logq];
 	ZZ cnstZZ = logp < 0 ? EvaluatorUtils::scaleUpToZZ(cnst, cipher.logp) : EvaluatorUtils::scaleUpToZZ(cnst, logp);
 	AddMod(cipher.bx[0], cipher.bx[0], cnstZZ, q);
@@ -449,33 +449,33 @@ void Scheme::addConstAndEqual(Ciphertext& cipher, complex<double> cnst, long log
 
 //-----------------------------------------
 
-void Scheme::sub(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::sub(Ciphertext& res, const Ciphertext &cipher1, const Ciphertext &cipher2) {
 	ZZ q = ring.qpows[cipher1.logq];
 	res.copyParams(cipher1);
 	ring.sub(res.ax, cipher1.ax, cipher2.ax, q);
 	ring.sub(res.bx, cipher1.bx, cipher2.bx, q);
 }
 
-void Scheme::subAndEqual(Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::subAndEqual(Ciphertext& cipher1, const Ciphertext &cipher2) {
 	ZZ q = ring.qpows[cipher1.logq];
 	ring.subAndEqual(cipher1.ax, cipher2.ax, q);
 	ring.subAndEqual(cipher1.bx, cipher2.bx, q);
 }
 
-void Scheme::subAndEqual2(Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::subAndEqual2(Ciphertext& cipher1, const Ciphertext &cipher2) {
 	ZZ q = ring.qpows[cipher1.logq];
 	ring.subAndEqual2(cipher1.ax, cipher2.ax, q);
 	ring.subAndEqual2(cipher1.bx, cipher2.bx, q);
 }
 
-void Scheme::imult(Ciphertext& res, Ciphertext& cipher) {
+void Scheme::imult(Ciphertext& res, const Ciphertext &cipher) {
 	ZZ q = ring.qpows[cipher.logq];
 	res.copyParams(cipher);
 	ring.multByMonomial(res.ax, cipher.ax, Nh);
 	ring.multByMonomial(res.bx, cipher.bx, Nh);
 }
 
-void Scheme::idiv(Ciphertext& res, Ciphertext& cipher) {
+void Scheme::idiv(Ciphertext& res, const Ciphertext &cipher) {
 	ZZ q = ring.qpows[cipher.logq];
 	res.copyParams(cipher);
 	ring.multByMonomial(res.ax, cipher.ax, 3 * Nh);
@@ -492,7 +492,7 @@ void Scheme::idivAndEqual(Ciphertext& cipher) {
 	ring.multByMonomialAndEqual(cipher.bx, 3 * Nh);
 }
 
-void Scheme::mult(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::mult(Ciphertext& res, const Ciphertext &cipher1, const Ciphertext &cipher2) {
 	res.copyParams(cipher1);
 	res.logp += cipher2.logp;
 
@@ -546,7 +546,7 @@ void Scheme::mult(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2) {
 	delete[] raa;
 }
 
-void Scheme::multAndEqual(Ciphertext& cipher1, Ciphertext& cipher2) {
+void Scheme::multAndEqual(Ciphertext& cipher1, const Ciphertext &cipher2) {
 
 	ZZ q = ring.qpows[cipher1.logq];
 	ZZ qQ = ring.qpows[cipher1.logq + logQ];
@@ -603,7 +603,7 @@ void Scheme::multAndEqual(Ciphertext& cipher1, Ciphertext& cipher2) {
 
 //-----------------------------------------
 
-void Scheme::square(Ciphertext& res, Ciphertext& cipher) {
+void Scheme::square(Ciphertext& res, const Ciphertext &cipher) {
 	res.copyParams(cipher);
 	res.logp += cipher.logp;
 	ZZ q = ring.qpows[cipher.logq];
@@ -698,7 +698,7 @@ void Scheme::squareAndEqual(Ciphertext& cipher) {
 
 //-----------------------------------------
 
-void Scheme::multByConst(Ciphertext& res, Ciphertext& cipher, double cnst, long logp) {
+void Scheme::multByConst(Ciphertext& res, const Ciphertext &cipher, double cnst, long logp) {
 	ZZ q = ring.qpows[cipher.logq];
 	ZZ cnstZZ = EvaluatorUtils::scaleUpToZZ(cnst, logp);
 	ring.multByConst(res.ax, cipher.ax, cnstZZ, q);
@@ -707,7 +707,16 @@ void Scheme::multByConst(Ciphertext& res, Ciphertext& cipher, double cnst, long
 	res.logp += logp;
 }
 
-void Scheme::multByConst(Ciphertext& res, Ciphertext& cipher, complex<double> cnst, long logp) {
+void Scheme::multByConst(Ciphertext &res, const Ciphertext &cipher, const NTL::RR &cnst, long logp) {
+    ZZ q = ring.qpows[cipher.logq];
+    ZZ cnstZZ = EvaluatorUtils::scaleUpToZZ(cnst, logp);
+    ring.multByConst(res.ax, cipher.ax, cnstZZ, q);
+    ring.multByConst(res.bx, cipher.bx, cnstZZ, q);
+    res.copyParams(cipher);
+    res.logp += logp;
+}
+
+void Scheme::multByConst(Ciphertext& res, const Ciphertext &cipher, complex<double> cnst, long logp) {
 	res.copy(cipher);
 	multByConstAndEqual(res, cnst, logp);
 }
@@ -733,7 +742,7 @@ void Scheme::multByConstAndEqual(Ciphertext& cipher, double cnst, long logp) {
 	cipher.logp += logp;
 }
 
-void Scheme::multByConstAndEqual(Ciphertext& cipher, RR& cnst, long logp) {
+void Scheme::multByConstAndEqual(Ciphertext& cipher, const RR& cnst, long logp) {
 	ZZ q = ring.qpows[cipher.logq];
 	ZZ cnstZZ = EvaluatorUtils::scaleUpToZZ(cnst, logp);
 	ring.multByConstAndEqual(cipher.ax, cnstZZ, q);
diff --git a/HEAAN/src/Scheme.h b/HEAAN/src/Scheme.h
index 0c41b52..e8059d0 100644
--- a/HEAAN/src/Scheme.h
+++ b/HEAAN/src/Scheme.h
@@ -118,51 +118,53 @@ public:
 	//   HOMOMORPHIC OPERATIONS
 	//----------------------------------------------------------------------------------
 
-	void negate(Ciphertext& res, Ciphertext& cipher);
+	void negate(Ciphertext& res, const Ciphertext &cipher);
 
 	void negateAndEqual(Ciphertext& cipher);
 
-	void add(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2);
+	void add(Ciphertext& res, const Ciphertext &cipher1, const Ciphertext &cipher2);
 
-	void addAndEqual(Ciphertext& cipher1, Ciphertext& cipher2);
+	void addAndEqual(Ciphertext& cipher1, const Ciphertext &cipher2);
 
-	void addConst(Ciphertext& res, Ciphertext& cipher, double cnst, long logp);
+	void addConst(Ciphertext& res, const Ciphertext &cipher, double cnst, long logp);
 
-	void addConst(Ciphertext& res, Ciphertext& cipher, NTL::RR& cnst, long logp);
+	void addConst(Ciphertext& res, const Ciphertext &cipher, const NTL::RR &cnst, long logp);
 
-	void addConst(Ciphertext& res, Ciphertext& cipher, std::complex<double> cnst, long logp);
+	void addConst(Ciphertext& res, const Ciphertext &cipher, std::complex<double> cnst, long logp);
 
 	void addConstAndEqual(Ciphertext& cipher, double cnst, long logp);
 
-	void addConstAndEqual(Ciphertext& cipher, NTL::RR& cnst, long logp);
+	void addConstAndEqual(Ciphertext& cipher, const NTL::RR &cnst, long logp);
 
 	void addConstAndEqual(Ciphertext& cipher, std::complex<double> cnst, long logp);
 
-	void sub(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2);
+	void sub(Ciphertext& res, const Ciphertext &cipher1, const Ciphertext &cipher2);
 
-	void subAndEqual(Ciphertext& cipher1, Ciphertext& cipher2);
+	void subAndEqual(Ciphertext& cipher1, const Ciphertext &cipher2);
 
-	void subAndEqual2(Ciphertext& cipher1, Ciphertext& cipher2);
+	void subAndEqual2(Ciphertext& cipher1, const Ciphertext &cipher2);
 
-	void imult(Ciphertext& res, Ciphertext& cipher);
+	void imult(Ciphertext& res, const Ciphertext &cipher);
 
-	void idiv(Ciphertext& res, Ciphertext& cipher);
+	void idiv(Ciphertext& res, const Ciphertext &cipher);
 
 	void imultAndEqual(Ciphertext& cipher);
 
 	void idivAndEqual(Ciphertext& cipher);
 
-	void mult(Ciphertext& res, Ciphertext& cipher1, Ciphertext& cipher2);
+	void mult(Ciphertext& res, const Ciphertext &cipher1, const Ciphertext &cipher2);
 
-	void multAndEqual(Ciphertext& cipher1, Ciphertext& cipher2);
+	void multAndEqual(Ciphertext& cipher1, const Ciphertext &cipher2);
 
-	void square(Ciphertext& res, Ciphertext& cipher);
+	void square(Ciphertext& res, const Ciphertext &cipher);
 
 	void squareAndEqual(Ciphertext& cipher);
 
-	void multByConst(Ciphertext& res, Ciphertext& cipher, double cnst, long logp);
+	void multByConst(Ciphertext& res, const Ciphertext &cipher, double cnst, long logp);
 
-	void multByConst(Ciphertext& res, Ciphertext& cipher, std::complex<double> cnst, long logp);
+    void multByConst(Ciphertext& res, const Ciphertext &cipher, const NTL::RR& cnst, long logp);
+
+	void multByConst(Ciphertext& res, const Ciphertext &cipher, std::complex<double> cnst, long logp);
 
 	void multByConstVec(Ciphertext& res, Ciphertext& cipher, std::complex<double>* cnstVec, long logp);
 
@@ -170,7 +172,7 @@ public:
 
 	void multByConstAndEqual(Ciphertext& cipher, double cnst, long logp);
 
-	void multByConstAndEqual(Ciphertext& cipher, NTL::RR& cnst, long logp);
+	void multByConstAndEqual(Ciphertext& cipher, const NTL::RR& cnst, long logp);
 
 	void multByConstAndEqual(Ciphertext& cipher, std::complex<double> cnst, long logp);
 
